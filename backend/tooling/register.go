package tooling

import (
	"errors"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type RegistryData struct {
	Constructors []string
}

type EventData struct {
	Events []string
}

func GetConstructors(dir string) ([]string, error) {
	c := cases.Title(language.English)

	files, err := ListAllFiles(dir)
	if err != nil {
		return nil, err
	}

	suffix := c.String(strings.TrimSuffix(dir, "s"))
	pattern := `^func (New.*` + suffix + `)\(`

	var constructors []string
	for _, path := range files {
		constructor, err := FindMatchingLine(path, pattern)
		if err != nil || constructor == "" {
			continue
		}
		constructors = append(constructors, constructor)
	}

	return constructors, nil
}

func GenerateConstructorRegistry(dir string, constructors []string) error {
	f, err := os.Create(filepath.Join(dir, "registry.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	singular := strings.TrimSuffix(dir, "s")
	c := cases.Title(language.English)
	capitalized := c.String(singular)

	// Set type and var name
	varName := capitalized + "Registry"
	interfaceName := capitalized

	// Template string with dynamic package and variable
	tmpl := `// Code generated by tools/register.go DO NOT EDIT.
package {{ .Package }}

import "spyal/contracts"

var {{ .VarName }} = []contracts.New{{.Interface}}Func {
{{- range .Constructors }}
	{{ . }},
{{- end }}
}
`

	// Render it
	t := template.Must(template.New("registry").Parse(tmpl))
	return t.Execute(f, struct {
		Package      string
		VarName      string
		Interface    string
		Constructors []string
	}{
		Package:      dir,
		VarName:      varName,
		Interface:    interfaceName,
		Constructors: constructors,
	})
}

func GetEventTypes(dir string) ([]string, error) {
	c := cases.Title(language.English)

	files, err := ListAllFiles(dir)
	if err != nil {
		return nil, err
	}

	suffix := c.String(strings.TrimSuffix(dir, "s"))
	pattern := `^type ([A-Za-z0-9_]+` + suffix + `) struct {`

	var events []string
	for _, path := range files {
		constructor, err := FindMatchingLine(path, pattern)
		if err != nil || constructor == "" {
			continue
		}
		events = append(events, constructor)
	}

	return events, nil
}

func GenerateEventTypes(dir string, events []string) error {
	if len(events) == 0 {
		return errors.New("no evenets provided")
	}

	f, err := os.Create(filepath.Join(dir, "event_types.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	// Title-case each event for enum naming
	c := cases.Title(language.English)
	var enumNames []string
	for _, e := range events {
		enumNames = append(enumNames, c.String(e))
	}

	tmpl := `// Code generated by tools/register.go DO NOT EDIT.
package events

import (
	"spyal/contracts"
	)


const (
{{- range .EnumNames }}
	{{ . }} contracts.EventName = iota
{{- end }}
	EventNameCount
)

func GetEventName(e contracts.EventName) string {
	switch e {
{{- range .EnumNames }}
	case {{ . }}:
		return "{{ . }}"
{{- end }}
	case EventNameCount:
		return "Count"
	default:
		return "Unknown"
	}
}
`

	t := template.Must(template.New("event_types").Parse(tmpl))
	return t.Execute(f, struct {
		EnumNames []string
	}{
		EnumNames: enumNames,
	})
}
