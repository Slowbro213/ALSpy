package tooling

import (
	"errors"
	"os"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"
	"go/ast"
	"go/parser"
	"go/token"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type RegistryData struct {
	Constructors []string
}

type EventData struct {
	Events []string
}

const (
	generatedCodeMsg = "// Code generated by tools/register.go DO NOT EDIT."
)

func GetConstructors(dir string) ([]string, error) {
	c := cases.Title(language.English)

	files, err := ListAllFiles(dir)
	if err != nil {
		return nil, err
	}

	suffix := c.String(strings.TrimSuffix(dir, "s"))
	pattern := `^func (New.*` + suffix + `)\(`

	var constructors []string
	for _, path := range files {
		constructor, err := FindMatchingLine(path, pattern)
		if err != nil || constructor == "" {
			continue
		}
		constructors = append(constructors, constructor)
	}

	return constructors, nil
}

//gosec:disable
func GenerateConstructorRegistry(dir string, constructors []string) error {
	f, err := os.Create(filepath.Join(dir, "registry.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	singular := strings.TrimSuffix(dir, "s")
	c := cases.Title(language.English)
	capitalized := c.String(singular)

	// Set type and var name
	varName := capitalized + "Registry"
	interfaceName := capitalized

	// Template string with dynamic package and variable
	tmpl := generatedCodeMsg + `
package {{ .Package }}

import "spyal/contracts"

var {{ .VarName }} = []contracts.New{{.Interface}}Func {
{{- range .Constructors }}
	{{ . }},
{{- end }}
}
`

	// Render it
	t := template.Must(template.New("registry").Parse(tmpl))
	return t.Execute(f, struct {
		Package      string
		VarName      string
		Interface    string
		Constructors []string
	}{
		Package:      dir,
		VarName:      varName,
		Interface:    interfaceName,
		Constructors: constructors,
	})
}

func GetEventTypes(dir string) ([]string, error) {
	c := cases.Title(language.English)

	files, err := ListAllFiles(dir)
	if err != nil {
		return nil, err
	}

	suffix := c.String(strings.TrimSuffix(dir, "s"))
	pattern := `^type ([A-Za-z0-9_]+` + suffix + `) struct {`

	var events []string
	for _, path := range files {
		constructor, err := FindMatchingLine(path, pattern)
		if err != nil || constructor == "" {
			continue
		}
		events = append(events, constructor)
	}

	return events, nil
}

//gosec:disable
func GenerateEventTypes(dir string, events []string) error {
	if len(events) == 0 {
		return errors.New("no evenets provided")
	}

	f, err := os.Create(filepath.Join(dir, "registry.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	// Title-case each event for enum naming
	c := cases.Title(language.English)
	var enumNames []string
	for _, e := range events {
		enumNames = append(enumNames, c.String(e))
	}

	tmpl := generatedCodeMsg + `
package events

import (
	"spyal/contracts"
	)


const (
{{- range .EnumNames }}
	{{ . }} contracts.EventName = iota
{{- end }}
	EventNameCount
)

func GetEventName(e contracts.EventName) string {
	switch e {
{{- range .EnumNames }}
	case {{ . }}:
		return "{{ . }}"
{{- end }}
	case EventNameCount:
		return "Count"
	default:
		return "Unknown"
	}
}
`

	t := template.Must(template.New("registry").Parse(tmpl))
	return t.Execute(f, struct {
		EnumNames []string
	}{
		EnumNames: enumNames,
	})
}

//nolint
func GetChannelConstructors(dir string) ([]string, error) {
	fset := token.NewFileSet()
	channelTypes := []string{}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") || info.Name() == "registry.go" {
			return err
		}

		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return err
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}

			for _, spec := range gen.Specs {
				ts := spec.(*ast.TypeSpec)
				structType, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				for _, field := range structType.Fields.List {
					if len(field.Names) == 0 {
						ident, ok := field.Type.(*ast.SelectorExpr)
						if ok && ident.Sel.Name == "Channel" {
							channelTypes = append(channelTypes, ts.Name.Name)
						}
					}
				}
			}
		}

		return nil
	})

	return channelTypes, err
}

//gosec:disable
func GenerateChannelRegistryFile(dir string, constructors []string) error {
	outFile := filepath.Join(dir, "registry.go")

	out := `// Code generated by tools/register.go DO NOT EDIT.
package channels

import (
	"spyal/contracts"
)

//nolint:gochecknoglobals
var Channels = map[string]contracts.Channel{
`

	for _, t := range constructors {
		name := strings.ToLower(t)
		out += fmt.Sprintf("    \"%s\": New%sChannel(),\n", name, t)
	}

	out += "}\n"

	writeFilePermissions := 0600
	return os.WriteFile(outFile, []byte(out), os.FileMode(writeFilePermissions))
}
